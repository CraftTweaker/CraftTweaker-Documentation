# Логика требований синтаксиса

Теперь, когда вы знаете, какие логические ворота я могу описать синтаксис, реализованный в Reskillable, что позволяет их использовать. Более подробные примеры будут приведены в следующем разделе.

Во всех синтаксисах ниже `требования` - это строковое представление любого другого поддерживаемого требования (включая те, которые добавлены CompatSkills или другими дополнениями).

* * *

## Универсальные ворота

### НЕ требуется

Самая простая логика в том, что поддержка Reskillable заключается в способности инвертировать требования. Это делает это с использованием **НЕ** ворот и синтаксис для него `не|требование`. As described above in the section about Logic Gates, this logic requirement will only be marked as met if the specified `requirement` is not met.

* * *

## Двоичные ворота

The other logic requirements are slightly more complex as they take two *input* requirements. Поскольку логические ворота относительно простые, порядок требований на самом деле не имеет значения, Однако я буду ссылаться на них как на `требование<sub>1</sub>` и `требование<sub>2</sub>` , чтобы отличить какой из них.

Они также делятся синтаксисом: `шлюз|[requirement<sub>1</sub>]~[requirement<sub>2</sub>]`. При наличии ворот `и`, `nand`, `или`, `ни`, `xor`, или `xnor`.  
**Примечание**: Необходимы квадратные скобки для `требования<sub>1</sub>` и требование `<sub>2</sub>`.

* * *

### И Требования

Требование **И** в отличие от других логических требований в основном полезно для вложенных логических требований (более чем на ниже), как блокирование элемента или другого объекта с множеством требований требует соблюдения всех данных требований. Это то же самое, что и функциональность **И** , поэтому используйте, когда это возможно, , так как это сделает всплывающие подсказки более удобными для чтения.

## Примеры

Все приведенные ниже примеры будут показаны с использованием синтаксиса из поддержки CompatSkill, поскольку проще читать. Логические требования работают очень хорошо и из конфигурации.

Все приведенные ниже сценарии CrT скрипты используют оператор импорта: `import mods.compatskills.Requirement. ddRequirement;` это прежде всего уменьшение длины других линий и сделать их более читаемыми. (Если вы копируете любой из примеров, вам нужно будет включить его в верхнюю часть файла скрипта. Несколько примеров ниже, которые непосредственно начинаются с `модов. ompatskills.` — это замки, которые специфичны для CompatSkills и которые я разработал с достойными примерами логики.

* * *

Только атакующие свинозомби за пределами Небе: `mods.compatskills.EntityDamageLock.addEntityLock(<entity:minecraft:zombie_pigman>, "не|dim|-1");`

* * *

Позволить зайти в Незер, если у игрока есть атака или уровень защиты не менее 15: `mods.compatskills.DimensionLock.addDimensionLock(-1, "или|[reskillable:attack|15]~[reskillable:defense|15]");`

* * *

Как только игрок достигнет 24 уровня защиты и 24 уровня ловкости, он сможет использовать кожаную броню:

    addRequirement(<minecraft:leather_helmet:*>, "nand|[reskillable:defense|24]~[reskillable:agility|24]");
    addRequirement(<minecraft:leather_chestplate:*>, "nand|[reskillable:defense|24]~[reskillable:agility|24]");
    addRequirement(<minecraft:leather_leggings:*>, "nand|[reskillable:defense|24]~[reskillable:agility|24]");
    addRequirement(<minecraft:leather_boots:*>, "nand|[reskillable:defense|24]~[reskillable:agility|24]");
    

* * *

Разрешите использовать деревянную лопату только до тех пор, пока игрок не достигнет уровня добычи или сбора 5: `addRequirement(<minecraft:wooden_shovel:*>, "nor|[reskillable:mining|5]~[reskillable:gathering|5]");`

* * *

Игроку разрешается использовать Эндер-жемчуг, только если у них 32 магии, или если у него 32. Однако не дайте им использовать эти навыки, если у них есть навыки на уровне 32: `addRequirement(<minecraft:ender_pearl>, "xor|[reskillable:magic|32]~[reskillable:agility|32]");`. Это может быть полезно, если вы хотите иметь многоуровневые деревья прогресса и убедитесь, что они должны следовать за ними, если они хотят продолжать использовать определенные элементы.

* * *

Было трудно привести пример **XNOR**, однако это пример того, как он может работать.

Разрешать защиту игрока только до 5 уровня, если он еще не поставил очки в атаку или если он находится на 32 уровне атаки: `модов. ompatskills.SkillLocks.addLevelLock(<skill:reskillable:defense>, 5, "xnor|[reskillable:attack|2]~[reskillable:attack|32]");`

### Вложенные логические требования

Вложенные логические требования заключаются в том, что вы используете логическое требование в качестве одного из параметров требования `` в другой логической требования. Особое внимание уделяется размещению скобок в вложенных требованиях.

* * *

Разрешите разбить алмазную руду только в том случае, если у игрока уровень добычи 20 или уровень сбора 25 и добыча 15: `добавление требований<minecraft:diamond_ore>, "или|[reskillable:mining|20]~[и|[reskillable:gathering|25]~[reskillable:mining|15]]");` *Примечание*: Это также имеет побочный эффект, позволяющий игрокам размещать алмазную руду, если она не удовлетворяет требованиям.

* * *

Разрешите использовать элитру только с ловкостью 15 в конце или с уровнем ловкости и магии 25 пока нет в конце: `addRequirement(<minecraft:elytra:*>, "xor|[и|[dim|1]~[reskillable:agility|15]]~[и|[reskillable:agility|25]~[reskillable:magic|25]]");` *Заметка*: После достижения ловкости и магии 25 вы не сможете использовать элитру в конце. Это отчасти просто в качестве примера, а не обязательно то, что хочет.

Вышеуказанное требование может быть написано: `addRequirement(<minecraft:elytra:*>, "reskillable:agility|15", "xor|[dim|1]~[and|[reskillable:agility|25]~[reskillable:magic|25]]");` потому что обе стороны требуют по крайней мере ловкость 15.