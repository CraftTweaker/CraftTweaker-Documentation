# `Тег`

`Тег` это объектное представление того, что хранится внутри фактического внутриигрового Тега. Доступ к этим данным можно получить только из в пределах [`тегов` загрузчика](/Mods/Boson/Loaders/Tags/). Для получения дополнительной информации о тегах и их получении обратитесь к на [этой странице](/Mods/Boson/Tags/Concept/).

## Детали урока
Класс находится в пакете `net.thesilkminer.mc.boson.zen.tag` , что делает `net.thesilkminer.mc.boson.zen.tag.Tag` его полное имя для импорта.

## Создание нового экземпляра
См. [документацию обработчика скобок](/Mods/Boson/Tags/BracketHandler/).

## Свойства
`Тег` предоставляет доступ только для чтения определённому набору свойств, как описано в следующей таблице:

| Название свойства | Тип                                          | Описание                                           |
| ----------------- | -------------------------------------------- | -------------------------------------------------- |
| `имя`             | [`Пробел имени`](/Mods/Boson/Names/)         | Имя которое уникально идентифицирует этот тег      |
| `type`            | [`TagType`](/Mods/Boson/Tags/TagType/)       | Тип этого тега                                     |
| `элементы`        | `[T]` (где `T` представляет собой общий тип) | Список элементов тега, доступных только для чтения |

## Методы

### Сложение
Добавление элементов к метке может быть сделано путем тройки методов, подписи которых находятся в сниппете, которые следуют:

```zenscript
add(elements... as NameSpacedString) как void;
function addAll(elements as any[]) as void;
function addFrom(other as Tag) as void;
```

`add` является так называемым "методом vararg", это означает, что он может принять столько аргументов по желанию, при условии, что они все одного типа, i. . `Пробел имени`s. Это позволяет указать имя реестра элемента, который вы хотите добавить в тег , и сама реализация тега попытается преобразовать данное имя в фактический объект.

`addAll`, с другой стороны, принимает массив элементов и пытается добавить их все в заданный тег. Массив помечен как `любой[]` из-за отсутствия общей поддержки для этого метода ввода. Тем не менее попытка добавить к тегу не совместимые элементы (скажем, добавление блоков к тегу только для элемента) приведет к выполнению неоптовой операции.

`addFrom` добавляет все содержимое тега к другому через ссылку Tag, означает, что любые изменения, произведенные на второй тег, также происходят с первым. Заметьте, что эта операция успешна только в том случае, если типы тегов совпадают, в противном случае будет выполнена операция " ".

Ниже приведен список примеров:

```zenscript
val tag = <tag-items:forge:ingots/iron>;

# добавлять элементы через имя реестра
тэг. dd("minecraft:iron_ingot" как NameSpacedString, "thermalfoundation:iron_ingot" как NameSpacedString);

# добавлять элементы через их фактические экземпляры
тэг. ddAll([<buildcraft:iron_ingot>] в качестве IItemStack[]);

# добавьте другой тег по ссылке
tag.addFrom(<tag-items:customtag:other_iron_ingots>);
```

### Замена
Elements of a tag can be replaced fully, meaning that all the contents are first cleared, then the given elements are added to the tag contents. Это достигается также путем тройки методов, подписи которых находятся в сниппете, который следующим образом:

```zenscript
заменить (элементы... как NameSpacedString) как недействительный;
функция replaceAll(элементы как любое[]) как недействительна;
функция заменаWith(другие как Тег) как недействительна;
```

`заменить` является так называемым "методом переменной", это означает, что он может принять столько аргументов, сколько нужно, при условии, что они все одного типа, i. . `Пробел имени`s. Это позволяет указать имя реестра элемента , который вы хотите использовать для замены содержимого тега, и реализация этого тега сама попытается преобразовать данное имя в фактический объект.

`заменить все`, с другой стороны, принимает массив элементов и пытается заменить содержимое данного тега с помощью массива . Массив помечен как `любой[]` из-за отсутствия общей поддержки для этого метода ввода. Тем не менее попытка передать несовместимые элементы тегу (скажем, блоки только для тега элемента) позволят выполнить операцию.

`Заменить` содержимое данного метки заменено на ссылку на другой, означает, что любые изменения выполненные во втором теге также происходят с первым. Заметьте, что эта операция успешна только в том случае, если типы тегов совпадают, в противном случае будет выполнена операция no-op.

Ниже приведен список примеров:

```zenscript
val tag = <tag-items:forge:ingots/iron>;

# заменить элементы через имя реестра
тэг. eplace("minecraft:iron_ingot" как NameSpacedString, "thermalfoundation:iron_ingot" как NameSpacedString);

# заменить элементы фактическими экземплярами
тегом. eplaceAll([<buildcraft:iron_ingot>] в качестве IItemStack[]);

# заменить другой тег ссылкой на тег
tag.replaceWith(<tag-items:customtag:other_iron_ingots>);
```

### Удаление
Удаление элементов из тэга может быть сделано путем тройки методов, подписи которых находятся в сниппете, следующим образом:

```zenscript
function remove(elements... as NameSpacedString) as void;
function removeAll(elements as any[]) as void;
function removeFrom(other as Tag) as void;
```

`удалить` является так называемым "методом переменной", это означает, что он может принять столько аргументов, сколько нужно, при условии, что они все одного типа, i. . `Пробел имени`s. Это позволяет указать имя реестра элемента, который вы хотите удалить из тега, и сама реализация тега попытается преобразовать данное имя в фактический объект.

`удалить все`, с другой стороны, принимает массив элементов и пытается удалить их все из заданного тега. Массив помечен как `любой[]` из-за отсутствия общей поддержки для этого метода ввода. Тем не менее попытка удалить из тега несовместимые элементы (скажем, удаление блоков из тега только для элемента) приведет к выполненной неоптовой операции

`removeFrom` удаляет второй тег из списка ссылок на теги первого тега. Следовательно, это удалит элементы, которые несет второй тег из списка первых элементов, хотя во втором тэге не будет очищено содержимое . Заметьте, что эта операция успешна только в том случае, если типы тегов совпадают, в противном случае будет выполнена операция без.

Ниже приведен список примеров:

```zenscript
val tag = <tag-items:forge:ingots/iron>;

# удалить элементы через имя реестра
тэг. emove("minecraft:iron_ingot" как NameSpacedString, "thermalfoundation:iron_ingot" как NameSpacedString);

# удалять элементы фактическими экземплярами
тегов. emoveAll([<buildcraft:iron_ingot>] как IItemStack[]);

# удалить ссылку на тег
tag.removeFrom(<tag-items:customtag:other_iron_ingots>);
```

### Очистка
Вы также можете очистить содержимое тега одним методом. Это удалит все элементы и все ссылки тегов в теге и эквивалентно замене тега пустым содержимым. Это может быть сделано методом, который имеет следующую подпись:

```zenscript
функция clear() как void;
```

Ниже приведен пример:

```zenscript
<tag-items:forge:ingots>.clear();
```

## Дополнительная поддержка
Теги также предлагают дополнительную поддержку некоторых функций ZenScript.

### Запрос
By using the `has` syntax, it is possible to query whether a tag contains a certain object or not. Тег фактически можно рассматривать как коллекцию элементов:

```zenscript
val istained = TAG имеет ELEMENT;
```

`TAG` представляет экземпляр тега для запроса. `ЭЛЕМЕНТ` представляет экземпляр элемента, который вы можете запросить проверить, содержится ли он в теге или нет.

Обратите внимание, что хотя теги поддерживают запрос чего-либо (он эффективно принимает `любой`), при использовании элемента, не используемого в тип, который хранится в теге, не имеет эффекта и просто короткий контур вычисления в `false`.

### Итерация
Теги также поддерживают итерацию через итеративный цикл с использованием обычного цикла `для`. Таким образом устранена необходимость запрашивания элементов с помощью вызова к элементам `` , что приводит к чистому коду.

Since tags are effectively a set, iteration order is not preserved and may differ between different runs of the iterator. По этой причине поддерживаются только итераторы с одним элементом (то есть вы также не можете запрашивать индекс итерации при итерации).

Используемый синтаксис:

```zenscript
для VARNAME в TAG {
}
```

`VARNAME` представляет имя переменной, которая будет обновляться в каждом цикле. `TAG` является экземпляром тега для цикла.

## Перегрузка оператора
Теги также обеспечивают некоторую перегрузку нормальных операторов ZenScript, так что некоторые операции могут быть выполнены легко и с меньше символов. В каждом разделе размещена таблица определенных перегрузок оператора, имеющая значение . Во всех таблицах `TAG` представляет пример целевого тега, в то время как `ARGx` представляет *x*-ый аргумент, который должен быть поставлен.

### Операторы Unary
Операторы Unary - это операторы, которые применяются к самому тегу и не принимают аргументов.

| ?   | Синтаксис | Эквивалент метода | Примечания |
| --- | --------- | ----------------- | ---------- |
| `-` | `-Тег`    | `очистить`        | \-        |

### Двоичные операторы
Двоичные операторы являются нефиксными операторами, которые применяются между тегом и одним аргументом. Операторы перечислены здесь в порядке очередности (выше это означает, что будут применены первые).

**ВАЖНО**: если не указано иное, все операторы **мутировать** тег, который перегружается, что означает, что они изменяют их содержимое. Рассмотрим следующий пример:

```zenscript
val tag = <tag-items:forge:ingots>;
тег & [<minecraft:iron_ingot>] как IItemStack[];
```

В конце этого фрагмента содержимое `тега` будет изменено в соответствии с правилами оператора. Это **не** создать новый тег, и он не возвращает исходное значение тега. Следующий фрагмент кода не действителен:

```zenscript
val tag = <tag-items:forge:ingots>;
# НЕ VALID: БУДУТ КОМПИЛЯЦИЯ ОШИБКА
tag = tag & [<minecraft:iron_ingot>] как IItemStack[];
```

| ?       | Тип аргумента                        | Синтаксис        | Эквивалент метода | Примечания                                                                       |
| ------- | ------------------------------------ | ---------------- | ----------------- | -------------------------------------------------------------------------------- |
| `+`     | `Тег`                                | `TAG + ARG1`     | `Добавить От`     | \-                                                                              |
| `+`     | `любой[]`                            | `TAG + ARG1`     | `addAll`          | Тип массива должен совпадать с содержанием тега                                  |
| `+`     | [`Пробел имени`](/Mods/Boson/Names/) | `TAG + ARG1`     | `Добавить`        | Перегрузка принимает только один аргумент                                        |
| `+`     | `any`                                | `TAG + ARG1`     | `addAll`          | Кратко для одного элемента: применяются те же правила, что и версия массива      |
| `~`     | `Тег`                                | `TAG ~ ARG1`     | `Добавить От`     | \-                                                                              |
| `~`     | `любой[]`                            | `TAG ~ ARG1`     | `addAll`          | Тип массива должен совпадать с содержанием тега                                  |
| `~`     | [`Пробел имени`](/Mods/Boson/Names/) | `TAG ~ ARG1`     | `Добавить`        | Перегрузка принимает только один аргумент                                        |
| `~`     | `any`                                | `TAG ~ ARG1`     | `addAll`          | Кратко для одного элемента: применяются те же правила, что и версия массива      |
| `&` | `Тег`                                | `TAG & ARG1` | `Добавить От`     | \-                                                                              |
| `&` | `любой[]`                            | `TAG & ARG1` | `addAll`          | Тип массива должен совпадать с содержанием тега                                  |
| `&` | [`Пробел имени`](/Mods/Boson/Names/) | `TAG & ARG1` | `Добавить`        | Перегрузка принимает только один аргумент                                        |
| `&` | `any`                                | `TAG & ARG1` | `addAll`          | Кратко для одного элемента: применяются те же правила, что и версия массива      |
| `-`     | `Тег`                                | `TAG - ARG1`     | `убрать из`       | \-                                                                              |
| `-`     | `любой[]`                            | `TAG - ARG1`     | `удалить все`     | Тип массива должен совпадать с содержанием тега                                  |
| `-`     | [`Пробел имени`](/Mods/Boson/Names/) | `TAG - ARG1`     | `удалить`         | Перегрузка принимает только один аргумент                                        |
| `-`     | `any`                                | `TAG - ARG1`     | `удалить все`     | Кратко для одного элемента: применяются те же правила, что и версия массива      |
| `==`    | `Тег`                                | `TAG == ARG1`    | \-               | Действует как проверка равенства, соответствующего содержанию; не мутирует `TAG` |
| `()`    | \-                                  | `TAG()`          | `элементы`        | \-                                                                              |
