# Концепция

Зацикливание - это старая концепция и один из основ программирования: повторяя один и тот же набор действий над группой элементов , при фильтрации некоторых из них или конвертации наборов. Или даже найти первый элемент в списке, который удовлетворяет определенному условию или считать элементы в наборе рекурсивно.

При разработке процедурных и императивных программ большинство из них было сделано с простыми старыми `для циклов` и серией условных утверждений с их относительными `продолжить` и `сломать` операции. Хотя это может показаться проще подписаться, он требует много кода для простых операций, таких как фильтрация и может вызвать вложенные цепи, которые могут длиться дольше. Более того, он не выражает намерения, если в коде не указаны комментарии.

Рассмотрим следующий код ZenScript:

```zenscript
var nbtForMc = false;

для рецепта в рецептах. ll {
    if (recipe.shaped) {
        val output = recipes. utput;
        если (! sNull(output)) {
            if (output. efinition.owner == "minecraft") {
                val hasData = output. asTag;
                if (hasData) {
                    nbtForMc = true;
                    перерыва;
                }
            }
        }
    }
}
```

То, что этот код не видит с первого взгляда и требует от пользователя прочитать логику для понимания. Рассмотрим этот эквивалент, построенный по последовательностям:

```zenscript
val nbtForMc = <sequence:ICraftingRecipe>(recipes.all)
    .filter(function (recipe) { return recipe. haped; })
    .map(function (recipe) { return recipe.output; })
    . ilterNot(function (output) { return isNull(output); })
    .filter(function (output) { return output. efinition.owner == "minecraft"; })
    .any(function (output) { return output.hasTag; });
```

Этот код делает одинаковый и не только более сжатый, но также передает больше смысла, что цепочка вложенных `, если` операторов. Предоставлено, это не похоже на общее улучшение, из-за простоты соответствующего кода, но это может оказаться полезным для более сложных частей логики.

Другой про-код из приведенного выше кода заключается в том, что вычисление не выполняется до `любого` вызова, , что последовательность может быть расширена дополнительным методом с течением времени, и она не будет разрешена до вызова метода "терминал" (i). . метод, который не возвращает саму `последовательность`). Это очень полезно, поскольку нет необходимости оценивать целых `рецептов. Все` массив.

Для начала и использования последовательностей вы можете обратиться как к [документам класса](/Mods/Boson/Sequences/Docs/) так и [как получить одну](/Mods/Boson/Sequences/Obtaining/) страницу документации.
