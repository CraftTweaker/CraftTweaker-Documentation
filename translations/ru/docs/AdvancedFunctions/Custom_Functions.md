# Пользовательские функции

Иногда функций, предоставляемые CT и аддонами, просто не будет хватать. Вот как писать свои собственные функции! Вы можете даже вложить функции в функции

## Базовый синтаксис

В целом, вы определяете функцию статически с помощью:

```zenscript
function имя([arguments[as тип данных]]) [as возвращаемый тип]{
    [выражения]
    [return значение;]
}
```

То, что в скобках необязательно в зависимости от того, что вы хотите достичь. Давайте рассмотрим конкретные функции.

## Статические функции

Статические функции создаются перед выполнением скрипта и могут быть доступны из любого места в скрипте.  
Вы можете получить доступ к функциям, объявленным вне скрипта, используя [перекрестную ссылку](/AdvancedFunctions/Cross-Script_Reference).

### Функции без возвращаемого значения

Безграничные функции - это функции, которые не возвращают никакого значения.

```zenscript
//вызывает функцию tens() без аргументов
tens();

//вызывает функцию realTens() со строкой "Hello World!" в качестве аргумента
realTens("Hello World! );


//crates function tens() без необходимых аргументов
function tens(){
    //Calls function realTens() с "" в качестве аргумента
    realTens("");
}


//создает функцию realTens() с одной строкой, требуемой в качестве аргумента
function realTens(a as string){
    //выводит аргумент 10 раз
    for i in 1 to 11{
        print(a);
    }
}
```

### Функции с возвращаемым значением

Вы также можете указать значение, которое должна быть возвращена функцией. Рекомендуется использовать ключевое слово `в качестве` для определения возвращаемого типа.

```zenscript
//вызывает добавление функции с 1 и 99 параметрами
результата = add(1,99);
print(result);

//вы можете поместить функцию добавления внутри функции печати и
print(add(2,64));

//определяет функцию add() с параметрами и b (оба задаются как целые числа! и устанавливает тип возврата в целое число
(как int, as int) as int{
    //возвращает сумму a and b
    return a+b;
}
```

## Функции как переменные

Вы также можете использовать функции как переменные. В этом случае, они будут создаваться как отдельные классы. Кроме того, они работают довольно точно так же, как статические функции, вы вызываете их по имени переменной.  
Вы можете использовать их даже в качестве [глобальных переменных](/AdvancedFunctions/Global_Static_Variables/) таким образом.

Если вам нужно охарактеризовать метод (как для глобальных) вы можете использовать это:

    global addition as function(int, int)int = function (a as int, b as int) as int {
        return a + b;
    };
    
    print(addition(1,2));