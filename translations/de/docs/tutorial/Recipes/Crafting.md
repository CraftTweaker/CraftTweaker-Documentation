# Crafting Recipes

## What are Crafting Recipes

Crafting Recipes are recipes that can be crafted in a Crafting Grid such as the 2x2 grid in the player's inventory or the 3x3 grid in a Crafting Table.


## Accessing the Crafting Recipe Manager

As discussed in [Recipe Managers](/tutorial/Recipes/RecipeManagers/), accessing the recipe manager will allow you to modify existing recipes or add new ones.

There are two ways to get the Crafting Recipe Manager:

1) Using the Global variable:
```zenscript
craftingTable
```
2) Using the BracketHandler
```zenscript
<recipetype:minecraft:crafting>
```

Both methods will give you the same Recipe Manager, so there is no benefit to using one over the other.

## Types of Crafting Recipes

Vanilla has many different types of Crafting Recipes, some of them are specialized such as the recipe to clone a Book or the recipe to make Suspicious Stew, but there are also more abstract recipes such as Shapeless recipes and Shaped recipes, which are the main recipes that you will be working with.

:::group{name="Shapeless Recipes"}

Shapeless Recipes are recipes where the ingredients can be placed in any order in the Crafting Table.  
An example of a Shapeless recipe is the Flint and Steel recipe, whre you can place the Flint and Iron Ingot in any slot and in any order in the Crafting Table and it will still produce the same output.

:::

:::group{name="Shaped Recipes"}

Shaped Recipes are recipes where the order of the ingredients matter, they need to be in a specific shape for the reciep to craft.  
An example of a shaped recipe is the Bucket recipe, where the Iron Ingots need to be placed in the correct order for it to Craft.

While Shaped recipe need to follow the specific pattern, they do not always need to be placed in the exact slot.  
Using the Bucket example, both of the recipes below are valid recipes for the Iron Bucket, even though the items are placed in different slots on the grid.

![Bucket With Ingots in the top two rows](https://blamejared.com/docsImages/bucket_top.png)

![Bucket with Ingots in the bottom two rows](https://blamejared.com/docsImages/bucket_bottom.png)

This effect is achieved by not filling out the full 3x3 grid, an example of how to add a recipe like this is below. :::

## Methoden

:::group{name=addShapeless}

This method is used to add a Shapeless Crafting recipe to the game.

The basic syntax for a shapeless recipe is:

```zenscript
// craftingTable.addShapeless(recipeName as string, 
//      output as IItemStack,
//      ingredients as IIngredient[], 
//      recipeFunction as @optional RecipeFunctionArray);
```

The optional RecipeFunctionArray at the end of the method is only needed for advanced recipe where the output changes depending on the input, an example being transfering NBT data from one of the input ingredients to the output item.

In general, most of your recipes are not going to be using the function, but it is there if you need it.

The `recipeName` has some restrictions that should be kept in mind: 1) The name you provide is the "path" value of the name of the recipe, all recipes added through CraftTweaker will have the `crafttweaker` modid as part of the name.<br/>For example, if you provide "boat" as the name, the full recipe name will be `crafttweaker:boat`. 2) It needs to be unique, using a non-unique recipe name will cause your recipe to replace the previous recipe. 3) It cannot contain spaces or colons (`:`). 4) It must be all lowercased. 5) It cannot start with `"autogenerated/"` as it is a reserved CraftTweaker folder.

For the `output`, something to note is that it **has** to be an [IItemStack](/vanilla/api/items/IItemStack/), passing in an [IIngredient](/vanilla/api/items/IIngredient/) will **not** work, so using `<tag:items:minecraft:wool>` or `<item:minecraft:diamond> | <item:minecraft:dirt>` will not work as they are both [IIngredients](/vanilla/api/items/IIngredient/), but using `<item:minecraft:diamond>` is valid and will work.

Here is an example of how to add a Shapeless recipe that will accept a single Dirt in any slot of the Crafting Grid and produce 2 Diamonds.

For a recipe like this, you don't need the recipe function, so it is simply left out.

```zenscript
craftingTable.addShapeless("dirt2diamond", <item:minecraft:diamond> * 2, [<item:minecraft:dirt>]);
```

This next Shapeless recipe is an example of how to use the RecipeFunction to change the output based on the input items.

The Shapeless recipe will give a piece of Dirt when a single Diamond is put into any slot in the Crafting Grid, however, if the input Diamond has the name "Super Diamond", it will produce 8 Dirt from a single Diamond.

```zenscript
craftingTable.addShapeless("diamond2dirt", <item:minecraft:dirt>, [<item:minecraft:diamond>],
(usualOut as IItemStack, inputs as IItemStack[]) => {

    if <item:minecraft:diamond>.withTag({display: {Name: "{\"text\":\"Super Diamond\"}"}}).matches(inputs[0]) {
        return usualOut * 8;
    }

    return usualOut;

});
```

Another example of how the Recipefunction can be used is to repair items.

The following script will accept a _damaged_ Iron Sword and a Clay Ball and will remove 10 damage from the Iron Sword.

Something to note with this recipe, we are returning the input itemstack as the output Item.  
This allows us return the exact itemstack that was used as the input, so if the itemstack had any enchantments or was renamed, it will retain those enchants and name.

Something else to note is the use of `onlyDamage()` on the Iron Sword input.  
This makes it that the recipe will only accept a damaged Iron Sword, if the Iron Sword has full durability, it won't be accepted.

```zenscript
craftingTable.addShapeless("iron_sword_repair", <item:minecraft:iron_sword>, [<item:minecraft:iron_sword>.onlyDamaged(), <item:minecraft:clay_ball>],
(usualOut as IItemStack, inputs as IItemStack[]) => {

    var newDamage = inputs[0].damage - 10;
    if newDamage < 0 {

        newDamage = 0;
    }
        return inputs[0].withDamage(newDamage);
});
```
:::


:::group{name=addShaped}

This method is used to add a Shaped Crafting recipe to the game.

The basic syntax for a shaped recipe is:

```zenscript
// craftingTable.addShaped(recipeName as string, 
//      output as IItemStack,
//      ingredients as IIngredient[][], 
//      recipeFunction as @optional RecipeFunctionMatrix);
```

The optional RecipeFunctionMatrix at the end of the method is only needed for advanced recipe where the output changes depending on the input, an example being transfering NBT data from one of the input ingredients to the output item.

In general, most of your recipes are not going to be using the function, but it is there if you need it.

The `recipeName` has some restrictions that should be kept in mind: 1) The name you provide is the "path" value of the name of the recipe, all recipes added through CraftTweaker will have the `crafttweaker` modid as part of the name.<br/>For example, if you provide "boat" as the name, the full recipe name will be `crafttweaker:boat`. 2) It needs to be unique, using a non-unique recipe name will cause your recipe to replace the previous recipe. 3) It cannot contain spaces or colons (`:`). 4) It must be all lowercased. 5) It cannot start with `"autogenerated/"` as it is a reserved CraftTweaker folder.

For the `output`, something to note is that it **has** to be an [IItemStack](/vanilla/api/items/IItemStack/), passing in an [IIngredient](/vanilla/api/items/IIngredient/) will **not** work, so using `<tag:items:minecraft:wool>` or `<item:minecraft:diamond> | <item:minecraft:dirt>` will not work as they are both [IIngredients](/vanilla/api/items/IIngredient/), but using `<item:minecraft:diamond>` is valid and will work.

Here is an example of how to add a Shaped recipe that will accept three pieces of Dirt, one in the top left slot, one in the center middle slot and one in the top right slot and output a Diamond.

For a recipe like this, you don't need the recipe function, so it is simply left out.

Something to note with this recipe, because we are only using 2 rows, the recipe can be exactly like the Bucket recipe is made in the examples above.

```zenscript
craftingTable.addShaped("dirt_bucket_to_diamond", <item:minecraft:diamond>, [
    [<item:minecraft:dirt>, <item:minecraft:air>, <item:minecraft:dirt>], 
    [<item:minecraft:air>, <item:minecraft:dirt>, <item:minecraft:air>]]);
```

The next Shaped recipe is an example of how you can force the recipe to require items in specific slots, even if the recipe only uses 2 rows of items like the Bucket recipe above.

The recipe will accept a single Apple only in the bottom left slot, and will output an Arrow.

The reason that this will only accept the apple in the bottom left slot is because we put `<item:minecraft:air>` in the other slots.

```zenscript
craftingTable.addShaped("apple_to_arrow", <item:minecraft:arrow>, [
    [<item:minecraft:air>, <item:minecraft:air>, <item:minecraft:air>], 
    [<item:minecraft:air>, <item:minecraft:air>, <item:minecraft:air>], 
    [<item:minecraft:apple>, <item:minecraft:air>, <item:minecraft:air>]]);
```

This next Shaped recipe is an example of how to use the RecipeFunction to change the output based on the input items.

The Shaped recipe will give a piece of Dirt when a Diamond is put into the left slot and an Apple is put into the center middle in the Crafting Grid, however, if the input Apple has the name "Super Apple", it will produce 8 Dirt.

The way that you reference items from the inputs is using the index of where they are in the input array, so because apple is at row 1 column 1, we use `[1][1]` to reference it, even though the recipe is 2x2 and the apple may not be in the center middle slot of the Crafting Grid.
```zenscript
craftingTable.addShaped("diamond_and_apples_to_dirt", <item:minecraft:dirt>, [
    [<item:minecraft:diamond>, <item:minecraft:air>], 
    [<item:minecraft:air>, <item:minecraft:apple>]],
(usualOut as IItemStack, inputs as IItemStack[][]) => {

    if <item:minecraft:apple>.withTag({display: {Name: "{\"text\":\"Super Apple\"}"}}).matches(inputs[1][1]) {
        return usualOut * 8;
    }

    return usualOut;

});
```
:::